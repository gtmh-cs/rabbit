using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using System;
using System.Collections.Generic;
using System.Text;

namespace GTMH.Rabbit.RPC.CodeGen
{
  [Generator]
  public class RPCCodeGenerator : IIncrementalGenerator
  {
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
      context.RegisterPostInitializationOutput(g=>
      {
        g.AddSource(
          "GTMH.IDL.g.cs",
@"
namespace GTMH.IDL
{
  // https://andrewlock.net/exploring-dotnet-10-preview-features-4-solving-the-source-generator-marker-attribute-problem-in-dotnet-10/
  //[global::Microsoft.CodeAnalysis.EmbeddedAttribute]
  [System.AttributeUsage(System.AttributeTargets.Interface)]
  public class RPCInterfaceAttribute : System.Attribute { }
  // https://andrewlock.net/exploring-dotnet-10-preview-features-4-solving-the-source-generator-marker-attribute-problem-in-dotnet-10/
  //[global::Microsoft.CodeAnalysis.EmbeddedAttribute]
  [System.AttributeUsage(System.AttributeTargets.Method)]
  public class RPCMethodAttribute : System.Attribute { }
}
");
      });
      //System.Diagnostics.Debugger.Launch();
      IncrementalValuesProvider<InterfaceDefn?> defns = context.SyntaxProvider.CreateSyntaxProvider(
        predicate: (node, cancelToken)=> FastFilterTarget(node),
        transform: (ctx, cancelToken)=> DeepSeekTarget(ctx)
      ).Where( _=> ! ( _ is null )  );

      context.RegisterSourceOutput(defns, (spc, source) => WriteCommonCode(source, spc));
      context.RegisterSourceOutput(defns, (spc, source) => ClientCodeGen.Write((InterfaceDefn)source, spc)); // filtered for null above
      context.RegisterSourceOutput(defns, (spc, source) => ServerCodeGen.Write((InterfaceDefn)source, spc)); // filtered for null above
    }


    private void WriteCommonCode(InterfaceDefn? source, SourceProductionContext compiler)
    {
      if ( source == null ) return;
      var iface = source.Value;
      var code = new Code();
      var implClassName = iface.GetImplClassName("Common");
      code.WriteLine($"// Generated by {nameof(RPCCodeGenerator)}");
      foreach(var use in iface.Usings)
      {
        code.WriteLine(use);
      }
      if(!string.IsNullOrEmpty(iface.Namespace))
      {
        code.WriteLine($"namespace {iface.Namespace};");
      }
      code.WriteLine($"public static class {implClassName}");
      code.WriteLine("{");
      using(code.Indent())
      {
        var identity = string.IsNullOrEmpty(iface.Namespace)?iface.Name : $"{iface.Namespace}.{iface.Name}";

        //code.WriteLine($"public static string RPCIdentity(this {iface.Name} a_Interface)=>\"{identity}\";");
      }

      code.WriteLine("}");

      compiler.AddSource($"{implClassName}.g.cs", code.ToString());
    }

    private InterfaceDefn? DeepSeekTarget(GeneratorSyntaxContext ctx)
    {
      var iface = (InterfaceDeclarationSyntax)ctx.Node;
      foreach(var als in iface.AttributeLists)
      {
        foreach(var attributeSyntax in als.Attributes)
        {
          var attributeSymbol = ctx.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol as IMethodSymbol;
          if(attributeSymbol == null)
          {
            continue;
          }
          var acts = attributeSymbol.ContainingType;
          var fullName = acts.ToDisplayString();
          if(fullName == "GTMH.IDL.RPCInterfaceAttribute")
          {
            return ParseTargetInterface(ctx.SemanticModel, iface);
          }
        }
      }
      return null;
    }

    private InterfaceDefn ? ParseTargetInterface(SemanticModel semanticModel, InterfaceDeclarationSyntax ifaceDeclaration)
    {
      var ifaceSymbol = semanticModel.GetDeclaredSymbol(ifaceDeclaration) as INamedTypeSymbol;
      if(ifaceSymbol == null)
      {
        return null;
      }
      var ifaceName = ifaceSymbol.Name;
      var methods = new List<MethodDefn>();
      foreach(IMethodSymbol method in ifaceSymbol.GetMembers())
      {
        if(!HasRPCMethodTag(semanticModel, method))
        {
          continue;
        }
        methods.Add(ParseMethodDefn(semanticModel, method));
      }
      var usings = new List<string>();
      foreach(var use in ifaceDeclaration.SyntaxTree.GetCompilationUnitRoot().Usings)
      {
        usings.Add(use.ToString());
      }
      var ns = GetNamespace(ifaceDeclaration);
      return new InterfaceDefn(GetVisibility(ifaceDeclaration.Modifiers, ifaceDeclaration.Parent is TypeDeclarationSyntax), ifaceName, ns, usings, methods);
    }

    private static string GetVisibility(SyntaxTokenList modifiers, bool a_IsNested)
    {
      if (modifiers.Any(SyntaxKind.PublicKeyword))
          return "public";
      if (modifiers.Any(SyntaxKind.PrivateKeyword))
          return "private";
      if (modifiers.Any(SyntaxKind.ProtectedKeyword))
          return "protected";
      if (modifiers.Any(SyntaxKind.InternalKeyword))
          return "internal";

      // Default for interfaces is internal (if no modifier specified)
      if(a_IsNested)
      {
        // default is private
        return "private";
      }
      else
      {
        // default internal private
        return "internal";
      }
    }

    private MethodDefn ParseMethodDefn(SemanticModel semanticModel, IMethodSymbol method)
    {
      var name = method.Name;
      var returnType = method.ReturnType.ToDisplayString();
      // TODO assert not method.IsGenericMethod
      var args = new List<MethodArg>();
      foreach(var arg in method.Parameters)
      {
        args.Add( new MethodArg(arg.Type.ToDisplayString(), arg.Name) );
      }
      return new MethodDefn(returnType, name, args);
    }

    private bool HasRPCMethodTag(SemanticModel semanticModel, IMethodSymbol method)
    {
      var attrs = method.GetAttributes();
      if ( attrs == null || attrs.Length == 0 ) return false;
      foreach(var attr in attrs)
      {
        var cls = attr.AttributeClass;
        if ( cls !=null && cls.ToDisplayString() == "GTMH.IDL.RPCMethodAttribute") return true;
      }
      return false;
    }

    private bool FastFilterTarget(object node)
    {
      var iface = node as InterfaceDeclarationSyntax;
      if(iface == null) return false;
      if(iface.AttributeLists.Count == 0) return false;
      return true;
    }

    static string GetNamespace(BaseTypeDeclarationSyntax syntax)
    {
      // If we don't have a namespace at all we'll return an empty string
      // This accounts for the "default namespace" case
      string nameSpace = string.Empty;

      // Get the containing syntax node for the type declaration
      // (could be a nested type, for example)
      SyntaxNode potentialNamespaceParent = syntax.Parent;

      // Keep moving "out" of nested classes etc until we get to a namespace
      // or until we run out of parents
      while(potentialNamespaceParent != null &&
              !(potentialNamespaceParent is NamespaceDeclarationSyntax)
              && !(potentialNamespaceParent is FileScopedNamespaceDeclarationSyntax))
      {
        potentialNamespaceParent = potentialNamespaceParent.Parent;
      }

      // Build up the final namespace by looping until we no longer have a namespace declaration
      if(potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
      {
        // We have a namespace. Use that as the type
        nameSpace = namespaceParent.Name.ToString();

        // Keep moving "out" of the namespace declarations until we 
        // run out of nested namespace declarations
        while(true)
        {
          if(!( namespaceParent.Parent is NamespaceDeclarationSyntax parent ))
          {
            break;
          }

          // Add the outer namespace as a prefix to the final namespace
          nameSpace = $"{namespaceParent.Name}.{nameSpace}";
          namespaceParent = parent;
        }
      }

      // return the final namespace
      return nameSpace;
    }
  }
}
